'''
4.	Develop a logistic regression-like algorithm for the following cost function.

Y = 1 - Cost function goes from 100 to 0 linearly as hypothesis function goes from 0 to 1

Y = 0 - Cost function goes from 0 to 100 linearly as hypothesis function goes from 0 to 1

Compare results with those of the standard logistic algorithm.
'''

hθ(x) = g(θX)
g(z) = 1 / ( 1 + e (−z) )

d/dθ[ hθ(X) ] = d/dθ [ 1 / ( 1 + exp( -θX))]

d/dθ [-( 1 + exp(-θX) )] / ( 1 + exp(-θX) ) ** 2

- d/dθ [-θX ] * exp(-θX) / ( 1 + exp(-θX) ) ** 2

d/dθ[ hθ(x) ] = X * exp(-θX) / ( 1 + exp(-θX) ) ** 2


J(θ) = Cost = 100 - 100 * hθ(x)         when Y = 1
              100 * hθ(x)               when Y = 0
              
J(θ) = Yi * ( 100 - 100 * hθ(xi) ) + ( 1 - Yi ) * ( 100 * hθ(xi) )

dJ / dθ0 = 1 / m * sum i=1 to m(d/dθ0[ Yi * ( 100 - 100 * hθ(xi) ) + ( 1 - Yi ) * ( 100 * hθ(xi) ) ] )

 1 / m * sum i=1 to m( Yi * d/dθ0[ ( 100 - 100 * hθ(xi) ) ] + ( 1 - Yi ) * d/dθ0[ ( 100 * hθ(xi) ) ] )
 
 1 / m * sum i=1 to m( 100 * Yi * d/dθ0[ ( 1 - hθ(xi) ) ] + ( 100 - 100 * Yi ) * d/dθ0[ ( hθ(xi) ) ] )
 
 1 / m * sum i=1 to m( -100 * Yi * d/dθ0[ ( hθ(xi) ) ] + ( 100 - 100 * Yi ) * d/dθ0[ ( hθ(xi) ) ] ) 
 
 1 / m * sum i=1 to m( ( 100 - 200 * Yi ) * d/dθ0[ ( hθ(Xi) ) ] ) 
 
 1 / m * sum i=1 to m( ( 100 - 200 * Yi ) * (Xi * exp(-θXi) / ( 1 + exp(-θXi) ) ** 2) ] )  
 
dJ / dθ0 =   1 / m * sum i=1 to m( ( 100 - 200 * Yi ) * (Xi * exp(-θXi) / ( 1 + exp(-θXi) ) ** 2) ] )




gradj[J(θ)] = d/dθ[ Y  * ( 100 - 100 * hθ(x) )] + d/dθ[ ( 1 - Y ) * ( 100 * hθ(x) )]

100 * Y * d/dθ[ ( 1 - hθ(x) )] + ( 100 - 100 * Y ) * d/dθ[ hθ(x) ]

-100 * Y * d/dθ[  hθ(x) ] + ( 100 - 100 * Y ) * d/dθ[ hθ(x) ]




Y * d/dθ[( 100 - 100 * hθ(x) )] - ( 100 - 100 * Y ) * d/dθ[  hθ(x) ]

100 * Y * d/dθ[( 1 - hθ(x) )] - ( 100 - 100 * Y ) * d/dθ[  hθ(x) ]

-100 * Y * d/dθ[ hθ(x) ] - ( 100 - 100 * Y ) * d/dθ[  hθ(x) ]

-100 * Y * d/dθ[ hθ(x) ] + ( -100 + 100 * Y ) * d/dθ[  hθ(x) ]

-100 * d/dθ[ hθ(x) ]



-100 * d/dθ[ hθ(x) ]

-100 * d/dθ[ 1 / ( 1 + e (−θX) ) ]

100 / ( ( 1 + exp(−θX) ) ** 2 ) * d/dθ[ 1 + exp(−θX) ]  

100 / ( ( 1 + exp (−θX) ) ** 2 ) * d/dθ[ exp(−θX) ] 

100 / ( ( 1 + exp (−θX) ) **2 ) * exp(−θX) * d/dθ[ −θX ] 

100 / ( ( 1 + exp(−θX) ) ** 2 ) * exp(−θX) * -X

-100 * X * exp(−θX) / ( ( 1 + exp(−θX) ) ** 2 ) 


gradj[J(θ)] = -100 * X * exp(−θX) / ( ( 1 + exp(−θX) ) ** 2 ) 

θj = θj – α gradj[J(θ)] 

Algorithm: 
Step 1: Select an initial θ(1). 
Step 2: During iteration k
        θ(k+1) = θ(k) – α gradj[J(θ)]
        k=k+1
Step 3: If accuracy is acceptable, stop.  Otherwise, go to Step 2. 


*********Need to think about this******
One thing that stands out is that the gradient will be constant unlike when you 
use the standard logistic algorithm. Since we have only used a constant learning 
rate we are dependent on the gradient magnitude to adjust the rate we update 
theta. Since there will be no change in the adjustment magnitude to theta we 
will require a smaller learning rate to ensure we do not overshoot the minimum 
to early because once that happens we will not be able to lower the cost because 
we will just go back and forth between those two cost.
